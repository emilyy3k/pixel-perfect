import{hexToRgb}from"./lib/lib.js";let fragmentShader="#version 300 es\rprecision mediump float;\r\rout vec4 fragColor;\runiform sampler2D uOriginalTexture;\runiform float uSpriteAlpha;\runiform vec3 uSpriteTint;\r\runiform vec4 inputClampTarget;\r\rin vec2 vOriginalTextureCoord;\r\rfloat getClip(vec2 uv) {\rreturn step(3.5,\rstep(inputClampTarget.x, uv.x) +\rstep(inputClampTarget.y, uv.y) +\rstep(uv.x, inputClampTarget.z) +\rstep(uv.y, inputClampTarget.w));\r}\r\rvoid main() {\rvec2 uv = vOriginalTextureCoord;\r\rvec2 originalSize = vec2(textureSize(uOriginalTexture, 0));\r\rvec2 originalTexelSize = 1.0 / originalSize;\r\rvec2 boxSize = clamp(fwidth(uv) * originalSize, vec2(1e-5), vec2(1.0));\r\rvec2 tx = uv * originalSize - 0.5 * boxSize;\r\rvec2 txOffset = smoothstep(vec2(1.0) - boxSize, vec2(1.0), fract(tx));\r\rvec2 sampleUV = (floor(tx) + 0.5 + txOffset) * originalTexelSize;\r\rvec4 color = textureGrad(uOriginalTexture, clamp(sampleUV,inputClampTarget.xy,inputClampTarget.zw)*getClip(sampleUV), dFdx(uv), dFdy(uv)) * getClip(sampleUV);\rcolor.rgb *= uSpriteTint;\rcolor *= uSpriteAlpha;\rfragColor = color;\r}",vertexShader="#version 300 es\rprecision mediump float;\rin vec2 aVertexPosition;\r\runiform mat3 projectionMatrix;\runiform mat3 uOriginalUVMatrix;\r\rout vec2 vTextureCoord;\rout vec2 vOriginalTextureCoord;\r\runiform vec4 inputSize;\runiform vec4 outputFrame;\r\rvec4 filterVertexPosition(void) {\rvec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.f)) + outputFrame.xy;\r\rreturn vec4((projectionMatrix * vec3(position, 1.0f)).xy, 0.0f, 1.0f);\r}\r\rvec2 filterTextureCoord(void) {\rreturn aVertexPosition * (outputFrame.zw * inputSize.zw);\r}\r\rvoid main(void) {\rgl_Position = filterVertexPosition();\rvTextureCoord = filterTextureCoord();\rvOriginalTextureCoord = (uOriginalUVMatrix * vec3(vTextureCoord, 1.0f)).xy;\r}";class PixelPerfectFilter extends PIXI.Filter{originalUVMatrix;targetSprite;originalTexture;constructor(r){var e=new PIXI.Matrix;super(vertexShader,fragmentShader),this.uniforms.uOriginalUVMatrix=e,this.originalUVMatrix=e,r?.texture?(this.updatePlaceableData(r),console.log("pixel-perfect: Texture assigned to filter")):console.warn(`pixel-perfect: No texture found for placeable ${r.id}, skipping filter application.`),this.autoFit=!1}updateSpriteData(r){var e;r.texture&&((e=r.texture).valid?(this.originalTexture=e,this.uniforms.uOriginalTexture!==this.originalTexture&&(this.uniforms.uOriginalTexture=this.originalTexture),r.roundPixels||(r.roundPixels=!0),this.targetSprite=r):console.warn(`pixel-perfect: Texture is not valid for sprite mesh ${r}, skipping filter application.`))}updatePlaceableData(e){var i=e.mesh;if(i){this.updateSpriteData(i);var i=e.document?.alpha||1;this.uniforms.uSpriteAlpha!==i&&(this.uniforms.uSpriteAlpha=i);let r=null;null!==(r=game.release&&12<=parseFloat(game.release.version)?e.document?.texture?.tint?.rgb||[1,1,1]:(i=e.document?.texture?.tint||"#ffffff",hexToRgb(i)))&&this.uniforms.uSpriteTint!==r&&(this.uniforms.uSpriteTint=r)}else console.warn(`pixel-perfect: No sprite mesh found for placeable ${e.id}, skipping filter application.`)}apply(r,e,i,t){var a=this.originalTexture;a.uvMatrix||(a.uvMatrix=new PIXI.TextureMatrix(a,0)),a.uvMatrix.update(),this.uniforms.uOriginalTexture!==a&&(this.uniforms.uOriginalTexture=a),this.uniforms.uOriginalUVMatrix=r.calculateSpriteMatrix(this.originalUVMatrix,this.targetSprite).prepend(a.uvMatrix.mapCoord),this.uniforms.inputClampTarget=a.uvMatrix.uClampFrame,super.apply(r,e,i,t)}destroy(){this.originalTexture=void 0,this.targetSprite=void 0,this.originalUVMatrix=void 0}}export{PixelPerfectFilter};
//# sourceMappingURL=PixelArtFilter.js.map
