{"version":3,"file":"PixelArtFilter.js","sources":["PixelArtFilter.js"],"sourcesContent":["import { hexToRgb } from \"./lib/lib.js\";\n// shaders are pulled in by gulp during build\nlet fragmentShader = `#version 300 es\\r\\\nprecision mediump float;\\r\\\n\\r\\\nout vec4 fragColor;\\r\\\nuniform sampler2D uOriginalTexture;\\r\\\nuniform float uSpriteAlpha;\\r\\\nuniform vec3 uSpriteTint;\\r\\\n\\r\\\nuniform vec4 inputClampTarget;\\r\\\n\\r\\\nin vec2 vOriginalTextureCoord;\\r\\\n\\r\\\nfloat getClip(vec2 uv) {\\r\\\nreturn step(3.5,\\r\\\nstep(inputClampTarget.x, uv.x) +\\r\\\nstep(inputClampTarget.y, uv.y) +\\r\\\nstep(uv.x, inputClampTarget.z) +\\r\\\nstep(uv.y, inputClampTarget.w));\\r\\\n}\\r\\\n\\r\\\nvoid main() {\\r\\\nvec2 uv = vOriginalTextureCoord;\\r\\\n\\r\\\nvec2 originalSize = vec2(textureSize(uOriginalTexture, 0));\\r\\\n\\r\\\nvec2 originalTexelSize = 1.0 / originalSize;\\r\\\n\\r\\\nvec2 boxSize = clamp(fwidth(uv) * originalSize, vec2(1e-5), vec2(1.0));\\r\\\n\\r\\\nvec2 tx = uv * originalSize - 0.5 * boxSize;\\r\\\n\\r\\\nvec2 txOffset = smoothstep(vec2(1.0) - boxSize, vec2(1.0), fract(tx));\\r\\\n\\r\\\nvec2 sampleUV = (floor(tx) + 0.5 + txOffset) * originalTexelSize;\\r\\\n\\r\\\nvec4 color = textureGrad(uOriginalTexture, clamp(sampleUV,inputClampTarget.xy,inputClampTarget.zw)*getClip(sampleUV), dFdx(uv), dFdy(uv)) * getClip(sampleUV);\\r\\\ncolor.rgb *= uSpriteTint;\\r\\\ncolor *= uSpriteAlpha;\\r\\\nfragColor = color;\\r\\\n}`;\nlet vertexShader = `#version 300 es\\r\\\nprecision mediump float;\\r\\\nin vec2 aVertexPosition;\\r\\\n\\r\\\nuniform mat3 projectionMatrix;\\r\\\nuniform mat3 uOriginalUVMatrix;\\r\\\n\\r\\\nout vec2 vTextureCoord;\\r\\\nout vec2 vOriginalTextureCoord;\\r\\\n\\r\\\nuniform vec4 inputSize;\\r\\\nuniform vec4 outputFrame;\\r\\\n\\r\\\nvec4 filterVertexPosition(void) {\\r\\\nvec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.f)) + outputFrame.xy;\\r\\\n\\r\\\nreturn vec4((projectionMatrix * vec3(position, 1.0f)).xy, 0.0f, 1.0f);\\r\\\n}\\r\\\n\\r\\\nvec2 filterTextureCoord(void) {\\r\\\nreturn aVertexPosition * (outputFrame.zw * inputSize.zw);\\r\\\n}\\r\\\n\\r\\\nvoid main(void) {\\r\\\ngl_Position = filterVertexPosition();\\r\\\nvTextureCoord = filterTextureCoord();\\r\\\nvOriginalTextureCoord = (uOriginalUVMatrix * vec3(vTextureCoord, 1.0f)).xy;\\r\\\n}`;\n/**\n * A PIXI filter that renders pixel art with crisp, clean edges at any scale.\n *\n * The PixelPerfectFilter maintains the visual integrity of pixel art textures\n * when scaled or transformed in Foundry VTT. It prevents texture blurring and\n * anti-aliasing that would otherwise degrade the appearance of pixel art.\n *\n * This filter works by:\n * 1. Capturing the original texture from a Token or Tile\n * 2. Applying custom shader logic to ensure pixel-perfect rendering\n * 3. Maintaining proper alpha transparency and tint color\n *\n * @extends PIXI.Filter\n *\n * @example\n * ```typescript\n * // Apply to a token\n * const filter = new PixelPerfectFilter(myToken);\n * myToken.filters = [...(myToken.filters || []), filter];\n * ```\n *\n * @remarks\n * - Compatible with both Foundry VTT v11 and v12\n * - Handles different tint color formats between versions\n * - Requires the target object to have a valid texture\n * - Should be properly destroyed when no longer needed to prevent risk of memory leaks\n */\nexport class PixelPerfectFilter extends PIXI.Filter {\n    originalUVMatrix;\n    targetSprite;\n    originalTexture;\n    constructor(filterTarget) {\n        const originalUVMatrix = new PIXI.Matrix();\n        super(vertexShader, fragmentShader);\n        this.uniforms.uOriginalUVMatrix = originalUVMatrix;\n        this.originalUVMatrix = originalUVMatrix;\n        // Update texture uniforms\n        // if (filterTarget instanceof PrimarySpriteMesh) {\n        //   this.updateSpriteData(filterTarget);\n        // } else \n        if (filterTarget?.texture) {\n            this.updatePlaceableData(filterTarget);\n            console.log(\"pixel-perfect: Texture assigned to filter\");\n        }\n        else {\n            console.warn(`pixel-perfect: No texture found for placeable ${filterTarget.id}, skipping filter application.`);\n        }\n        this.autoFit = false;\n    }\n    /**\n     * Updates the sprite data for the pixel art filter.\n     *\n     * This method sets up the original texture from the sprite mesh and applies it to the filter's uniforms.\n     * It also ensures the sprite mesh has rounded pixels for better pixel-perfect rendering.\n     *\n     * @param spriteMesh - The primary sprite mesh to extract texture data from and apply pixel-perfect settings to\n     * @returns {void} - Returns early if the sprite mesh doesn't have a valid texture resource\n     */\n    updateSpriteData(spriteMesh) {\n        if (!spriteMesh.texture)\n            return;\n        let tex = spriteMesh.texture;\n        //console.log(\"pixel-perfect: Texture from sprite mesh\", tex);\n        if (!tex.valid) {\n            console.warn(`pixel-perfect: Texture is not valid for sprite mesh ${spriteMesh}, skipping filter application.`);\n            return;\n        }\n        this.originalTexture = tex;\n        // If the texture object has changed, update the uniforms\n        if (this.uniforms.uOriginalTexture !== this.originalTexture) {\n            this.uniforms.uOriginalTexture = this.originalTexture;\n        }\n        if (!spriteMesh.roundPixels) {\n            spriteMesh.roundPixels = true;\n        }\n        this.targetSprite = spriteMesh;\n    }\n    /**\n     * Updates the filter with data from a placeable (Token or Tile) object.\n     *\n     * This method extracts necessary information from the placeable to update the\n     * filter's uniforms, including sprite data, alpha transparency, and tint color.\n     * It handles version compatibility for Foundry VTT v11 and v12.\n     *\n     * @param placeable - The Token or Tile object whose data will be used to update the filter\n     * @returns {void}\n     *\n     * @remarks\n     * - Requires the placeable to have a valid mesh property\n     * - Will skip application and log a warning if no sprite mesh is found\n     * - Handles different tint color formats between Foundry VTT versions\n     */\n    updatePlaceableData(placeable) {\n        let spriteMesh = placeable.mesh;\n        if (!spriteMesh) {\n            console.warn(`pixel-perfect: No sprite mesh found for placeable ${placeable.id}, skipping filter application.`);\n            return;\n        }\n        this.updateSpriteData(spriteMesh);\n        const placeableAlpha = placeable.document?.alpha || 1.0;\n        // If the sprite alpha has changed, update the uniform\n        if (this.uniforms.uSpriteAlpha !== placeableAlpha) {\n            // Update the alpha uniform, from the placeable document\n            this.uniforms.uSpriteAlpha = placeableAlpha;\n        }\n        let newTint = null;\n        // update the tint color uniform, from the placeable document. default to white if not set\n        // Foundry v12 uses a different format for tint colors\n        if (game.release && parseFloat(game.release.version) >= 12) {\n            newTint = placeable.document?.texture?.tint?.rgb || [1, 1, 1];\n        }\n        else {\n            const tintHex = placeable.document?.texture?.tint || '#ffffff';\n            // @ts-ignore\n            newTint = hexToRgb(tintHex);\n        }\n        // If the tint color has changed, update the uniform\n        if (newTint !== null && this.uniforms.uSpriteTint !== newTint) {\n            this.uniforms.uSpriteTint = newTint;\n        }\n    }\n    /**\n     * Applies the pixel art filter to the rendered content.\n     *\n     * This method is called by PIXI's filter system during rendering. It prepares the original texture\n     * for use in the shader by setting up the necessary uniforms, including the texture itself and\n     * the UV transformation matrices required for proper mapping.\n     *\n     * @param filterManager - The PIXI FilterSystem managing the rendering pipeline\n     * @param input - The input render texture to apply the filter to\n     * @param output - The output render texture where the filtered result will be stored\n     * @param clear - The clear mode to use when applying the filter\n     *\n     * @returns {void} - The method returns early without applying the filter if the original texture is invalid\n     */\n    apply(filterManager, input, output, clear) {\n        const texture = this.originalTexture;\n        if (!texture.uvMatrix)\n            texture.uvMatrix = new PIXI.TextureMatrix(texture, 0.0);\n        texture.uvMatrix.update();\n        if (this.uniforms.uOriginalTexture !== texture) {\n            this.uniforms.uOriginalTexture = texture;\n        }\n        this.uniforms.uOriginalUVMatrix = filterManager\n            .calculateSpriteMatrix(this.originalUVMatrix, this.targetSprite)\n            .prepend(texture.uvMatrix.mapCoord);\n        this.uniforms.inputClampTarget = texture.uvMatrix.uClampFrame;\n        super.apply(filterManager, input, output, clear);\n    }\n    /**\n     * Destroys the PixelArtFilter instance, releasing references to resources for garbage collection.\n     *\n     * This method should be called when the filter is no longer needed to prevent memory leaks.\n     * It nullifies references to the original texture, target sprite, and original UV matrix.\n     */\n    destroy() {\n        // Null out references for GC\n        this.originalTexture = undefined;\n        this.targetSprite = undefined;\n        this.originalUVMatrix = undefined;\n    }\n}\n"],"names":["hexToRgb","let","fragmentShader","vertexShader","PixelPerfectFilter","PIXI","Filter","originalUVMatrix","targetSprite","originalTexture","constructor","filterTarget","Matrix","super","this","uniforms","uOriginalUVMatrix","texture","updatePlaceableData","console","log","warn","id","autoFit","updateSpriteData","spriteMesh","tex","valid","uOriginalTexture","roundPixels","placeable","mesh","placeableAlpha","document","alpha","uSpriteAlpha","newTint","game","release","parseFloat","version","tint","rgb","tintHex","uSpriteTint","apply","filterManager","input","output","clear","uvMatrix","TextureMatrix","update","calculateSpriteMatrix","prepend","mapCoord","inputClampTarget","uClampFrame","destroy","undefined"],"mappings":"OAASA,QAA8B,KAAd,eAEzBC,IAAIC,eAAiB,qjCAwCjBC,aAAe,2tBAuDNC,2BAA2BC,KAAKC,OACzCC,iBACAC,aACAC,gBACAC,YAAYC,GACR,IAAMJ,EAAmB,IAAIF,KAAKO,OAClCC,MAAMV,aAAcD,cAAc,EAClCY,KAAKC,SAASC,kBAAoBT,EAClCO,KAAKP,iBAAmBA,EAKpBI,GAAcM,SACdH,KAAKI,oBAAoBP,CAAY,EACrCQ,QAAQC,IAAI,2CAA2C,GAGvDD,QAAQE,sDAAsDV,EAAaW,kCAAkC,EAEjHR,KAAKS,QAAU,CAAA,CACnB,CAUAC,iBAAiBC,GACb,IAEIC,EAFCD,EAAWR,WAEZS,EAAMD,EAAWR,SAEZU,OAITb,KAAKL,gBAAkBiB,EAEnBZ,KAAKC,SAASa,mBAAqBd,KAAKL,kBACxCK,KAAKC,SAASa,iBAAmBd,KAAKL,iBAErCgB,EAAWI,cACZJ,EAAWI,YAAc,CAAA,GAE7Bf,KAAKN,aAAeiB,GAXhBN,QAAQE,4DAA4DI,iCAA0C,EAYtH,CAgBAP,oBAAoBY,GAChB7B,IAAIwB,EAAaK,EAAUC,KAC3B,GAAKN,EAAL,CAIAX,KAAKU,iBAAiBC,CAAU,EAChC,IAAMO,EAAiBF,EAAUG,UAAUC,OAAS,EAEhDpB,KAAKC,SAASoB,eAAiBH,IAE/BlB,KAAKC,SAASoB,aAAeH,GAEjC/B,IAAImC,EAAU,KAYE,QARZA,EADAC,KAAKC,SAA+C,IAApCC,WAAWF,KAAKC,QAAQE,OAAO,EACrCV,EAAUG,UAAUhB,SAASwB,MAAMC,KAAO,CAAC,EAAG,EAAG,IAGrDC,EAAUb,EAAUG,UAAUhB,SAASwB,MAAQ,UAE3CzC,SAAS2C,CAAO,KAGN7B,KAAKC,SAAS6B,cAAgBR,IAClDtB,KAAKC,SAAS6B,YAAcR,EArBhC,MAFIjB,QAAQE,0DAA0DS,EAAUR,kCAAkC,CAyBtH,CAeAuB,MAAMC,EAAeC,EAAOC,EAAQC,GAChC,IAAMhC,EAAUH,KAAKL,gBAChBQ,EAAQiC,WACTjC,EAAQiC,SAAW,IAAI7C,KAAK8C,cAAclC,EAAS,CAAG,GAC1DA,EAAQiC,SAASE,OAAO,EACpBtC,KAAKC,SAASa,mBAAqBX,IACnCH,KAAKC,SAASa,iBAAmBX,GAErCH,KAAKC,SAASC,kBAAoB8B,EAC7BO,sBAAsBvC,KAAKP,iBAAkBO,KAAKN,YAAY,EAC9D8C,QAAQrC,EAAQiC,SAASK,QAAQ,EACtCzC,KAAKC,SAASyC,iBAAmBvC,EAAQiC,SAASO,YAClD5C,MAAMgC,MAAMC,EAAeC,EAAOC,EAAQC,CAAK,CACnD,CAOAS,UAEI5C,KAAKL,gBAAkBkD,KAAAA,EACvB7C,KAAKN,aAAemD,KAAAA,EACpB7C,KAAKP,iBAAmBoD,KAAAA,CAC5B,CACJ,QAtIavD,kBAsIb"}