{"version":3,"file":"PixelArtFilter.js","sources":["PixelArtFilter.js"],"sourcesContent":["import { hexToRgb } from \"./lib/lib.js\";\n// shaders are pulled in by gulp during build\nlet fragmentShader = `#version 300 es\\r\\\nprecision mediump float;\\r\\\n\\r\\\nout vec4 fragColor;\\r\\\nuniform sampler2D uOriginalTexture;\\r\\\nuniform vec2 uTexSize;\\r\\\nuniform float uSpriteAlpha;\\r\\\nuniform vec3 uSpriteTint;\\r\\\n\\r\\\nuniform vec4 inputClampTarget;\\r\\\n\\r\\\nin vec2 vOriginalTextureCoord;\\r\\\n\\r\\\nfloat getClip(vec2 uv) {\\r\\\nbvec4 inBounds = bvec4(\\r\\\nuv.x >= inputClampTarget.x,\\r\\\nuv.y >= inputClampTarget.y,\\r\\\nuv.x <= inputClampTarget.z,\\r\\\nuv.y <= inputClampTarget.w\\r\\\n);\\r\\\nreturn float(all(inBounds));\\r\\\n}\\r\\\n\\r\\\nvoid main() {\\r\\\nvec2 uv = vOriginalTextureCoord;\\r\\\n\\r\\\nvec2 dUVdx = dFdx(uv);\\r\\\nvec2 dUVdy = dFdy(uv);\\r\\\n\\r\\\nvec2 originalSize = uTexSize;\\r\\\n\\r\\\nvec2 originalTexelSize = 1.0 / originalSize;\\r\\\n\\r\\\nvec2 boxSize = clamp((abs(dUVdx) + abs(dUVdy)) * originalSize, vec2(1e-5), vec2(1.0));\\r\\\n\\r\\\nvec2 tx = uv * originalSize - 0.5 * boxSize;\\r\\\n\\r\\\nvec2 txOffset = smoothstep(vec2(1.0) - boxSize, vec2(1.0), fract(tx));\\r\\\n\\r\\\nvec2 sampleUV = (floor(tx) + 0.5 + txOffset) * originalTexelSize;\\r\\\n\\r\\\nfloat clipValue = getClip(sampleUV);\\r\\\n\\r\\\nvec4 color = textureGrad(uOriginalTexture, clamp(sampleUV,inputClampTarget.xy,inputClampTarget.zw)*clipValue, dUVdx, dUVdy) * clipValue;\\r\\\ncolor.rgb *= uSpriteTint;\\r\\\ncolor *= uSpriteAlpha;\\r\\\nfragColor = color;\\r\\\n}`;\nlet vertexShader = `#version 300 es\\r\\\nprecision mediump float;\\r\\\nin vec2 aVertexPosition;\\r\\\n\\r\\\nuniform mat3 projectionMatrix;\\r\\\nuniform mat3 uOriginalUVMatrix;\\r\\\n\\r\\\nout vec2 vTextureCoord;\\r\\\nout vec2 vOriginalTextureCoord;\\r\\\n\\r\\\nuniform vec4 inputSize;\\r\\\nuniform vec4 outputFrame;\\r\\\n\\r\\\nvec4 filterVertexPosition(void) {\\r\\\nvec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.f)) + outputFrame.xy;\\r\\\n\\r\\\nreturn vec4((projectionMatrix * vec3(position, 1.0f)).xy, 0.0f, 1.0f);\\r\\\n}\\r\\\n\\r\\\nvec2 filterTextureCoord(void) {\\r\\\nreturn aVertexPosition * (outputFrame.zw * inputSize.zw);\\r\\\n}\\r\\\n\\r\\\nvoid main(void) {\\r\\\ngl_Position = filterVertexPosition();\\r\\\nvTextureCoord = filterTextureCoord();\\r\\\n\\r\\\nvOriginalTextureCoord = (uOriginalUVMatrix * vec3(vTextureCoord, 1.0f)).xy;\\r\\\n}`;\n/**\n * A PIXI filter that renders pixel art with crisp, clean edges at any scale.\n *\n * The PixelPerfectFilter maintains the visual integrity of pixel art textures\n * when scaled or transformed in Foundry VTT. It prevents texture blurring and\n * anti-aliasing that would otherwise degrade the appearance of pixel art.\n *\n * This filter works by:\n * 1. Capturing the original texture from a Token or Tile\n * 2. Applying custom shader logic to ensure pixel-perfect rendering\n * 3. Maintaining proper alpha transparency and tint color\n *\n * @extends PIXI.Filter\n *\n * @example\n * ```typescript\n * // Apply to a token\n * const filter = new PixelPerfectFilter(myToken);\n * myToken.filters = [...(myToken.filters || []), filter];\n * ```\n *\n * @remarks\n * - Compatible with both Foundry VTT v11 and v12\n * - Handles different tint color formats between versions\n * - Requires the target object to have a valid texture\n * - Should be properly destroyed when no longer needed to prevent risk of memory leaks\n */\nexport class PixelPerfectFilter extends PIXI.Filter {\n    originalUVMatrix;\n    targetSprite;\n    originalTexture;\n    lastWorldID = -1;\n    constructor(filterTarget) {\n        const originalUVMatrix = new PIXI.Matrix();\n        super(vertexShader, fragmentShader);\n        this.uniforms.uOriginalUVMatrix = originalUVMatrix;\n        this.originalUVMatrix = originalUVMatrix;\n        // Update texture uniforms\n        // if (filterTarget instanceof PrimarySpriteMesh) {\n        //   this.updateSpriteData(filterTarget);\n        // } else \n        if (filterTarget?.texture) {\n            this.updatePlaceableData(filterTarget);\n            console.log(\"pixel-perfect: Texture assigned to filter\");\n        }\n        else {\n            console.warn(`pixel-perfect: No texture found for placeable ${filterTarget.id}, skipping filter application.`);\n        }\n        this.autoFit = false;\n    }\n    /**\n     * Updates the sprite data for the pixel art filter.\n     *\n     * This method sets up the original texture from the sprite mesh and applies it to the filter's uniforms.\n     * It also ensures the sprite mesh has rounded pixels for better pixel-perfect rendering.\n     *\n     * @param spriteMesh - The primary sprite mesh to extract texture data from and apply pixel-perfect settings to\n     * @returns {void} - Returns early if the sprite mesh doesn't have a valid texture resource\n     */\n    updateSpriteData(spriteMesh) {\n        if (!spriteMesh.texture)\n            return;\n        let tex = spriteMesh.texture;\n        //console.log(\"pixel-perfect: Texture from sprite mesh\", tex);\n        if (!tex.valid) {\n            console.warn(`pixel-perfect: Texture is not valid for sprite mesh ${spriteMesh}, skipping filter application.`);\n            return;\n        }\n        this.originalTexture = tex;\n        // If the texture doesn't have a UV matrix, create one\n        if (!tex.uvMatrix) {\n            tex.uvMatrix = new PIXI.TextureMatrix(tex, 0.0);\n            tex.uvMatrix.update();\n        }\n        // If the texture object has changed, update the uniforms\n        if (this.uniforms.uOriginalTexture !== this.originalTexture) {\n            this.uniforms.uOriginalTexture = this.originalTexture;\n            this.uniforms.uTexSize = [tex.width, tex.height];\n        }\n        if (!spriteMesh.roundPixels) {\n            spriteMesh.roundPixels = true;\n        }\n        if (this.targetSprite !== spriteMesh) {\n            this.targetSprite = spriteMesh;\n        }\n    }\n    /**\n     * Updates the filter with data from a placeable (Token or Tile) object.\n     *\n     * This method extracts necessary information from the placeable to update the\n     * filter's uniforms, including sprite data, alpha transparency, and tint color.\n     * It handles version compatibility for Foundry VTT v11 and v12.\n     *\n     * @param placeable - The Token or Tile object whose data will be used to update the filter\n     * @returns {void}\n     *\n     * @remarks\n     * - Requires the placeable to have a valid mesh property\n     * - Will skip application and log a warning if no sprite mesh is found\n     * - Handles different tint color formats between Foundry VTT versions\n     */\n    updatePlaceableData(placeable) {\n        let spriteMesh = placeable.mesh;\n        if (!spriteMesh) {\n            console.warn(`pixel-perfect: No sprite mesh found for placeable ${placeable.id}, skipping filter application.`);\n            return;\n        }\n        this.updateSpriteData(spriteMesh);\n        const placeableAlpha = placeable.document?.alpha || 1.0;\n        // If the sprite alpha has changed, update the uniform\n        if (this.uniforms.uSpriteAlpha !== placeableAlpha) {\n            // Update the alpha uniform, from the placeable document\n            this.uniforms.uSpriteAlpha = placeableAlpha;\n        }\n        let newTint = null;\n        // update the tint color uniform, from the placeable document. default to white if not set\n        // Foundry v12 uses a different format for tint colors\n        if (game.release && parseFloat(game.release.version) >= 12) {\n            newTint = placeable.document?.texture?.tint?.rgb || [1, 1, 1];\n        }\n        else {\n            const tintHex = placeable.document?.texture?.tint || '#ffffff';\n            // @ts-ignore\n            newTint = hexToRgb(tintHex);\n        }\n        // If the tint color has changed, update the uniform\n        if (newTint !== null && this.uniforms.uSpriteTint !== newTint) {\n            this.uniforms.uSpriteTint = newTint;\n        }\n    }\n    /**\n     * Applies the pixel art filter to the rendered content.\n     *\n     * This method is called by PIXI's filter system during rendering. It prepares the original texture\n     * for use in the shader by setting up the necessary uniforms, including the texture itself and\n     * the UV transformation matrices required for proper mapping.\n     *\n     * @param filterManager - The PIXI FilterSystem managing the rendering pipeline\n     * @param input - The input render texture to apply the filter to\n     * @param output - The output render texture where the filtered result will be stored\n     * @param clear - The clear mode to use when applying the filter\n     *\n     * @returns {void} - The method returns early without applying the filter if the original texture is invalid\n     */\n    apply(filterManager, input, output, clear) {\n        const texture = this.originalTexture;\n        if (this.uniforms.uOriginalTexture !== texture) {\n            this.uniforms.uOriginalTexture = texture;\n        }\n        // prevent recalculating the UV matrix if the transform hasn't changed\n        if (this.targetSprite.transform._worldID !== this.lastWorldID) {\n            // Update the original UV matrix based on the target sprite's current transform\n            this.uniforms.uOriginalUVMatrix = filterManager\n                .calculateSpriteMatrix(this.originalUVMatrix, this.targetSprite)\n                .prepend(texture.uvMatrix.mapCoord);\n            this.lastWorldID = this.targetSprite.transform._worldID;\n        }\n        this.uniforms.inputClampTarget = texture.uvMatrix.uClampFrame;\n        super.apply(filterManager, input, output, clear);\n    }\n    /**\n     * Destroys the PixelArtFilter instance, releasing references to resources for garbage collection.\n     *\n     * This method should be called when the filter is no longer needed to prevent memory leaks.\n     * It nullifies references to the original texture, target sprite, and original UV matrix.\n     */\n    destroy() {\n        // Null out references for GC\n        this.originalTexture = undefined;\n        this.targetSprite = undefined;\n        this.originalUVMatrix = undefined;\n        this.lastWorldID = -1;\n        super.destroy();\n    }\n}\n"],"names":["hexToRgb","let","fragmentShader","vertexShader","PixelPerfectFilter","PIXI","Filter","originalUVMatrix","targetSprite","originalTexture","lastWorldID","constructor","filterTarget","Matrix","super","this","uniforms","uOriginalUVMatrix","texture","updatePlaceableData","console","log","warn","id","autoFit","updateSpriteData","spriteMesh","tex","valid","uvMatrix","TextureMatrix","update","uOriginalTexture","uTexSize","width","height","roundPixels","placeable","mesh","placeableAlpha","document","alpha","uSpriteAlpha","newTint","game","release","parseFloat","version","tint","rgb","tintHex","uSpriteTint","apply","filterManager","input","output","clear","transform","_worldID","calculateSpriteMatrix","prepend","mapCoord","inputClampTarget","uClampFrame","destroy","undefined"],"mappings":"OAASA,QAA8B,KAAd,eAEzBC,IAAIC,eAAiB,spCAgDjBC,aAAe,6tBAwDNC,2BAA2BC,KAAKC,OACzCC,iBACAC,aACAC,gBACAC,YAAc,CAAC,EACfC,YAAYC,GACR,IAAML,EAAmB,IAAIF,KAAKQ,OAClCC,MAAMX,aAAcD,cAAc,EAClCa,KAAKC,SAASC,kBAAoBV,EAClCQ,KAAKR,iBAAmBA,EAKpBK,GAAcM,SACdH,KAAKI,oBAAoBP,CAAY,EACrCQ,QAAQC,IAAI,2CAA2C,GAGvDD,QAAQE,sDAAsDV,EAAaW,kCAAkC,EAEjHR,KAAKS,QAAU,CAAA,CACnB,CAUAC,iBAAiBC,GACb,IAEIC,EAFCD,EAAWR,WAEZS,EAAMD,EAAWR,SAEZU,QAITb,KAAKN,gBAAkBkB,GAEdE,WACLF,EAAIE,SAAW,IAAIxB,KAAKyB,cAAcH,EAAK,CAAG,EAC9CA,EAAIE,SAASE,OAAO,GAGpBhB,KAAKC,SAASgB,mBAAqBjB,KAAKN,kBACxCM,KAAKC,SAASgB,iBAAmBjB,KAAKN,gBACtCM,KAAKC,SAASiB,SAAW,CAACN,EAAIO,MAAOP,EAAIQ,SAExCT,EAAWU,cACZV,EAAWU,YAAc,CAAA,GAEzBrB,KAAKP,eAAiBkB,IACtBX,KAAKP,aAAekB,IAlBpBN,QAAQE,4DAA4DI,iCAA0C,EAoBtH,CAgBAP,oBAAoBkB,GAChBpC,IAAIyB,EAAaW,EAAUC,KAC3B,GAAKZ,EAAL,CAIAX,KAAKU,iBAAiBC,CAAU,EAChC,IAAMa,EAAiBF,EAAUG,UAAUC,OAAS,EAEhD1B,KAAKC,SAAS0B,eAAiBH,IAE/BxB,KAAKC,SAAS0B,aAAeH,GAEjCtC,IAAI0C,EAAU,KAYE,QARZA,EADAC,KAAKC,SAA+C,IAApCC,WAAWF,KAAKC,QAAQE,OAAO,EACrCV,EAAUG,UAAUtB,SAAS8B,MAAMC,KAAO,CAAC,EAAG,EAAG,IAGrDC,EAAUb,EAAUG,UAAUtB,SAAS8B,MAAQ,UAE3ChD,SAASkD,CAAO,KAGNnC,KAAKC,SAASmC,cAAgBR,IAClD5B,KAAKC,SAASmC,YAAcR,EArBhC,MAFIvB,QAAQE,0DAA0De,EAAUd,kCAAkC,CAyBtH,CAeA6B,MAAMC,EAAeC,EAAOC,EAAQC,GAChC,IAAMtC,EAAUH,KAAKN,gBACjBM,KAAKC,SAASgB,mBAAqBd,IACnCH,KAAKC,SAASgB,iBAAmBd,GAGjCH,KAAKP,aAAaiD,UAAUC,WAAa3C,KAAKL,cAE9CK,KAAKC,SAASC,kBAAoBoC,EAC7BM,sBAAsB5C,KAAKR,iBAAkBQ,KAAKP,YAAY,EAC9DoD,QAAQ1C,EAAQW,SAASgC,QAAQ,EACtC9C,KAAKL,YAAcK,KAAKP,aAAaiD,UAAUC,UAEnD3C,KAAKC,SAAS8C,iBAAmB5C,EAAQW,SAASkC,YAClDjD,MAAMsC,MAAMC,EAAeC,EAAOC,EAAQC,CAAK,CACnD,CAOAQ,UAEIjD,KAAKN,gBAAkBwD,KAAAA,EACvBlD,KAAKP,aAAeyD,KAAAA,EACpBlD,KAAKR,iBAAmB0D,KAAAA,EACxBlD,KAAKL,YAAc,CAAC,EACpBI,MAAMkD,QAAQ,CAClB,CACJ,QAnJa5D,kBAmJb"}