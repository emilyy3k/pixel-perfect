{"version":3,"file":"PixelArtFilter.js","sources":["PixelArtFilter.js"],"sourcesContent":["import { hexToRgb } from \"./lib/lib.js\";\n// shaders are pulled in by gulp during build\nlet fragmentShader = `#version 300 es\\r\\\nprecision mediump float;\\r\\\n\\r\\\nout vec4 fragColor;\\r\\\nuniform sampler2D uOriginalTexture;\\r\\\nuniform vec2 uTexSize;\\r\\\nuniform float uSpriteAlpha;\\r\\\nuniform vec3 uSpriteTint;\\r\\\n\\r\\\nuniform vec4 inputClampTarget;\\r\\\n\\r\\\nin vec2 vOriginalTextureCoord;\\r\\\n\\r\\\nfloat getClip(vec2 uv) {\\r\\\nbvec4 inBounds = bvec4(\\r\\\nuv.x >= inputClampTarget.x,\\r\\\nuv.y >= inputClampTarget.y,\\r\\\nuv.x <= inputClampTarget.z,\\r\\\nuv.y <= inputClampTarget.w\\r\\\n);\\r\\\nreturn float(all(inBounds));\\r\\\n}\\r\\\n\\r\\\nvoid main() {\\r\\\nvec2 uv = vOriginalTextureCoord;\\r\\\n\\r\\\nvec2 dUVdx = dFdx(uv);\\r\\\nvec2 dUVdy = dFdy(uv);\\r\\\n\\r\\\nvec2 originalSize = uTexSize;\\r\\\n\\r\\\nvec2 originalTexelSize = 1.0 / originalSize;\\r\\\n\\r\\\nvec2 boxSize = clamp((abs(dUVdx) + abs(dUVdy)) * originalSize, vec2(1e-5), vec2(1.0));\\r\\\n\\r\\\nvec2 tx = uv * originalSize - 0.5 * boxSize;\\r\\\n\\r\\\nvec2 txOffset = smoothstep(vec2(1.0) - boxSize, vec2(1.0), fract(tx));\\r\\\n\\r\\\nvec2 sampleUV = (floor(tx) + 0.5 + txOffset) * originalTexelSize;\\r\\\n\\r\\\nfloat clipValue = getClip(sampleUV);\\r\\\n\\r\\\nvec4 color = textureGrad(uOriginalTexture, clamp(sampleUV,inputClampTarget.xy,inputClampTarget.zw)*clipValue, dUVdx, dUVdy) * clipValue;\\r\\\ncolor.rgb *= uSpriteTint;\\r\\\ncolor *= uSpriteAlpha;\\r\\\nfragColor = color;\\r\\\n}`;\nlet vertexShader = `#version 300 es\\r\\\nprecision mediump float;\\r\\\nin vec2 aVertexPosition;\\r\\\n\\r\\\nuniform mat3 projectionMatrix;\\r\\\nuniform mat3 uOriginalUVMatrix;\\r\\\n\\r\\\nout vec2 vTextureCoord;\\r\\\nout vec2 vOriginalTextureCoord;\\r\\\n\\r\\\nuniform vec4 inputSize;\\r\\\nuniform vec4 outputFrame;\\r\\\n\\r\\\nvec4 filterVertexPosition(void) {\\r\\\nvec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.f)) + outputFrame.xy;\\r\\\n\\r\\\nreturn vec4((projectionMatrix * vec3(position, 1.0f)).xy, 0.0f, 1.0f);\\r\\\n}\\r\\\n\\r\\\nvec2 filterTextureCoord(void) {\\r\\\nreturn aVertexPosition * (outputFrame.zw * inputSize.zw);\\r\\\n}\\r\\\n\\r\\\nvoid main(void) {\\r\\\ngl_Position = filterVertexPosition();\\r\\\nvTextureCoord = filterTextureCoord();\\r\\\n\\r\\\nvOriginalTextureCoord = (uOriginalUVMatrix * vec3(vTextureCoord, 1.0f)).xy;\\r\\\n}`;\n/**\n * A PIXI filter that renders pixel art with crisp, clean edges at any scale.\n *\n * The PixelPerfectFilter maintains the visual integrity of pixel art textures\n * when scaled or transformed in Foundry VTT. It prevents texture blurring and\n * anti-aliasing that would otherwise degrade the appearance of pixel art.\n *\n * This filter works by:\n * 1. Capturing the original texture from a Token or Tile\n * 2. Applying custom shader logic to ensure pixel-perfect rendering\n * 3. Maintaining proper alpha transparency and tint color\n *\n * @extends PIXI.Filter\n *\n * @example\n * ```typescript\n * // Apply to a token\n * const filter = new PixelPerfectFilter(myToken);\n * myToken.filters = [...(myToken.filters || []), filter];\n * ```\n *\n * @remarks\n * - Compatible with both Foundry VTT v11 and v12\n * - Handles different tint color formats between versions\n * - Requires the target object to have a valid texture\n * - Should be properly destroyed when no longer needed to prevent risk of memory leaks\n */\nexport class PixelPerfectFilter extends PIXI.Filter {\n    originalUVMatrix;\n    targetSprite;\n    originalTexture;\n    lastWorldID = -1;\n    filterCount = 0; // Number of filters applied to the target sprite\n    constructor(filterTarget) {\n        const originalUVMatrix = new PIXI.Matrix();\n        super(vertexShader, fragmentShader);\n        this.uniforms.uOriginalUVMatrix = originalUVMatrix;\n        this.originalUVMatrix = originalUVMatrix;\n        this.filterCount = filterTarget.mesh?.filters?.length || 0;\n        // Update texture uniforms\n        // if (filterTarget instanceof PrimarySpriteMesh) {\n        //   this.updateSpriteData(filterTarget);\n        // } else\n        if (filterTarget?.texture) {\n            this.updatePlaceableData(filterTarget);\n            console.log(\"pixel-perfect: Texture assigned to filter\");\n        }\n        else {\n            console.warn(`pixel-perfect: No texture found for placeable ${filterTarget.id}, skipping filter application.`);\n        }\n        this.autoFit = false;\n    }\n    /**\n     * Updates the sprite data for the pixel art filter.\n     *\n     * This method sets up the original texture from the sprite mesh and applies it to the filter's uniforms.\n     * It also ensures the sprite mesh has rounded pixels for better pixel-perfect rendering.\n     *\n     * @param spriteMesh - The primary sprite mesh to extract texture data from and apply pixel-perfect settings to\n     * @returns {void} - Returns early if the sprite mesh doesn't have a valid texture resource\n     */\n    updateSpriteData(spriteMesh) {\n        if (!spriteMesh.texture)\n            return;\n        let tex = spriteMesh.texture;\n        //console.log(\"pixel-perfect: Texture from sprite mesh\", tex);\n        if (!tex.valid) {\n            console.warn(`pixel-perfect: Texture is not valid for sprite mesh ${spriteMesh}, skipping filter application.`);\n            return;\n        }\n        this.originalTexture = tex;\n        // If the texture doesn't have a UV matrix, create one\n        if (!tex.uvMatrix) {\n            tex.uvMatrix = new PIXI.TextureMatrix(tex, 0.0);\n            tex.uvMatrix.update();\n        }\n        // If the texture object has changed, update the uniforms\n        if (this.uniforms.uOriginalTexture !== this.originalTexture) {\n            this.uniforms.uOriginalTexture = this.originalTexture;\n            this.uniforms.uTexSize = [tex.width, tex.height];\n        }\n        if (!spriteMesh.roundPixels) {\n            spriteMesh.roundPixels = true;\n        }\n        if (this.targetSprite !== spriteMesh) {\n            this.targetSprite = spriteMesh;\n        }\n    }\n    /**\n     * Updates the filter with data from a placeable (Token or Tile) object.\n     *\n     * This method extracts necessary information from the placeable to update the\n     * filter's uniforms, including sprite data, alpha transparency, and tint color.\n     * It handles version compatibility for Foundry VTT v11 and v12.\n     *\n     * @param placeable - The Token or Tile object whose data will be used to update the filter\n     * @returns {void}\n     *\n     * @remarks\n     * - Requires the placeable to have a valid mesh property\n     * - Will skip application and log a warning if no sprite mesh is found\n     * - Handles different tint color formats between Foundry VTT versions\n     */\n    updatePlaceableData(placeable) {\n        let spriteMesh = placeable.mesh;\n        if (!spriteMesh) {\n            console.warn(`pixel-perfect: No sprite mesh found for placeable ${placeable.id}, skipping filter application.`);\n            return;\n        }\n        this.lastWorldID = -1; // reset the last world ID to force a recalculation of the UV matrix\n        this.updateSpriteData(spriteMesh);\n        const placeableAlpha = placeable.document?.alpha || 1.0;\n        // If the sprite alpha has changed, update the uniform\n        if (this.uniforms.uSpriteAlpha !== placeableAlpha) {\n            // Update the alpha uniform, from the placeable document\n            this.uniforms.uSpriteAlpha = placeableAlpha;\n        }\n        let newTint = null;\n        // update the tint color uniform, from the placeable document. default to white if not set\n        // Foundry v12 uses a different format for tint colors\n        if (game.release && parseFloat(game.release.version) >= 12) {\n            newTint = placeable.document?.texture?.tint?.rgb || [1, 1, 1];\n        }\n        else {\n            const tintHex = placeable.document?.texture?.tint || \"#ffffff\";\n            // @ts-ignore\n            newTint = hexToRgb(tintHex);\n        }\n        // If the tint color has changed, update the uniform\n        if (newTint !== null && this.uniforms.uSpriteTint !== newTint) {\n            this.uniforms.uSpriteTint = newTint;\n        }\n    }\n    /**\n     * Applies the pixel art filter to the rendered content.\n     *\n     * This method is called by PIXI's filter system during rendering. It prepares the original texture\n     * for use in the shader by setting up the necessary uniforms, including the texture itself and\n     * the UV transformation matrices required for proper mapping.\n     *\n     * @param filterManager - The PIXI FilterSystem managing the rendering pipeline\n     * @param input - The input render texture to apply the filter to\n     * @param output - The output render texture where the filtered result will be stored\n     * @param clear - The clear mode to use when applying the filter\n     *\n     * @returns {void} - The method returns early without applying the filter if the original texture is invalid\n     */\n    apply(filterManager, input, output, clear) {\n        const texture = this.originalTexture;\n        if (this.uniforms.uOriginalTexture !== texture) {\n            this.uniforms.uOriginalTexture = texture;\n        }\n        const needsUpdate = this.targetSprite.transform._worldID !== this.lastWorldID ||\n            this.targetSprite.filters?.length !== this.filterCount;\n        // prevent recalculating the UV matrix if the transform hasn't changed\n        if (needsUpdate) {\n            // Update the original UV matrix based on the target sprite's current transform\n            this.uniforms.uOriginalUVMatrix = filterManager\n                .calculateSpriteMatrix(this.originalUVMatrix, this.targetSprite)\n                .prepend(texture.uvMatrix.mapCoord);\n            this.lastWorldID = this.targetSprite.transform._worldID;\n            this.filterCount = this.targetSprite.filters?.length || 0;\n        }\n        this.uniforms.inputClampTarget = texture.uvMatrix.uClampFrame;\n        super.apply(filterManager, input, output, clear);\n    }\n    /**\n     * Destroys the PixelArtFilter instance, releasing references to resources for garbage collection.\n     *\n     * This method should be called when the filter is no longer needed to prevent memory leaks.\n     * It nullifies references to the original texture, target sprite, and original UV matrix.\n     */\n    destroy() {\n        // Null out references for GC\n        this.originalTexture = undefined;\n        this.targetSprite = undefined;\n        this.originalUVMatrix = undefined;\n        this.lastWorldID = -1;\n        super.destroy();\n    }\n}\n"],"names":["hexToRgb","let","fragmentShader","vertexShader","PixelPerfectFilter","PIXI","Filter","originalUVMatrix","targetSprite","originalTexture","lastWorldID","filterCount","constructor","filterTarget","Matrix","super","this","uniforms","uOriginalUVMatrix","mesh","filters","length","texture","updatePlaceableData","console","log","warn","id","autoFit","updateSpriteData","spriteMesh","tex","valid","uvMatrix","TextureMatrix","update","uOriginalTexture","uTexSize","width","height","roundPixels","placeable","placeableAlpha","document","alpha","uSpriteAlpha","newTint","game","release","parseFloat","version","tint","rgb","tintHex","uSpriteTint","apply","filterManager","input","output","clear","needsUpdate","transform","_worldID","calculateSpriteMatrix","prepend","mapCoord","inputClampTarget","uClampFrame","destroy","undefined"],"mappings":"OAASA,QAA8B,KAAd,eAEzBC,IAAIC,eAAiB,spCAgDjBC,aAAe,6tBAwDNC,2BAA2BC,KAAKC,OACzCC,iBACAC,aACAC,gBACAC,YAAc,CAAC,EACfC,YAAc,EACdC,YAAYC,GACR,IAAMN,EAAmB,IAAIF,KAAKS,OAClCC,MAAMZ,aAAcD,cAAc,EAClCc,KAAKC,SAASC,kBAAoBX,EAClCS,KAAKT,iBAAmBA,EACxBS,KAAKL,YAAcE,EAAaM,MAAMC,SAASC,QAAU,EAKrDR,GAAcS,SACdN,KAAKO,oBAAoBV,CAAY,EACrCW,QAAQC,IAAI,2CAA2C,GAGvDD,QAAQE,sDAAsDb,EAAac,kCAAkC,EAEjHX,KAAKY,QAAU,CAAA,CACnB,CAUAC,iBAAiBC,GACb,IAEIC,EAFCD,EAAWR,WAEZS,EAAMD,EAAWR,SAEZU,QAIThB,KAAKP,gBAAkBsB,GAEdE,WACLF,EAAIE,SAAW,IAAI5B,KAAK6B,cAAcH,EAAK,CAAG,EAC9CA,EAAIE,SAASE,OAAO,GAGpBnB,KAAKC,SAASmB,mBAAqBpB,KAAKP,kBACxCO,KAAKC,SAASmB,iBAAmBpB,KAAKP,gBACtCO,KAAKC,SAASoB,SAAW,CAACN,EAAIO,MAAOP,EAAIQ,SAExCT,EAAWU,cACZV,EAAWU,YAAc,CAAA,GAEzBxB,KAAKR,eAAiBsB,IACtBd,KAAKR,aAAesB,IAlBpBN,QAAQE,4DAA4DI,iCAA0C,EAoBtH,CAgBAP,oBAAoBkB,GAChBxC,IAAI6B,EAAaW,EAAUtB,KAC3B,GAAKW,EAAL,CAIAd,KAAKN,YAAc,CAAC,EACpBM,KAAKa,iBAAiBC,CAAU,EAChC,IAAMY,EAAiBD,EAAUE,UAAUC,OAAS,EAEhD5B,KAAKC,SAAS4B,eAAiBH,IAE/B1B,KAAKC,SAAS4B,aAAeH,GAEjCzC,IAAI6C,EAAU,KAYE,QARZA,EADAC,KAAKC,SAA+C,IAApCC,WAAWF,KAAKC,QAAQE,OAAO,EACrCT,EAAUE,UAAUrB,SAAS6B,MAAMC,KAAO,CAAC,EAAG,EAAG,IAGrDC,EAAUZ,EAAUE,UAAUrB,SAAS6B,MAAQ,UAE3CnD,SAASqD,CAAO,KAGNrC,KAAKC,SAASqC,cAAgBR,IAClD9B,KAAKC,SAASqC,YAAcR,EAtBhC,MAFItB,QAAQE,0DAA0De,EAAUd,kCAAkC,CA0BtH,CAeA4B,MAAMC,EAAeC,EAAOC,EAAQC,GAChC,IAAMrC,EAAUN,KAAKP,gBAIfmD,GAHF5C,KAAKC,SAASmB,mBAAqBd,IACnCN,KAAKC,SAASmB,iBAAmBd,GAEjBN,KAAKR,aAAaqD,UAAUC,WAAa9C,KAAKN,aAC9DM,KAAKR,aAAaY,SAASC,SAAWL,KAAKL,aAE3CiD,IAEA5C,KAAKC,SAASC,kBAAoBsC,EAC7BO,sBAAsB/C,KAAKT,iBAAkBS,KAAKR,YAAY,EAC9DwD,QAAQ1C,EAAQW,SAASgC,QAAQ,EACtCjD,KAAKN,YAAcM,KAAKR,aAAaqD,UAAUC,SAC/C9C,KAAKL,YAAcK,KAAKR,aAAaY,SAASC,QAAU,GAE5DL,KAAKC,SAASiD,iBAAmB5C,EAAQW,SAASkC,YAClDpD,MAAMwC,MAAMC,EAAeC,EAAOC,EAAQC,CAAK,CACnD,CAOAS,UAEIpD,KAAKP,gBAAkB4D,KAAAA,EACvBrD,KAAKR,aAAe6D,KAAAA,EACpBrD,KAAKT,iBAAmB8D,KAAAA,EACxBrD,KAAKN,YAAc,CAAC,EACpBK,MAAMqD,QAAQ,CAClB,CACJ,QAzJahE,kBAyJb"}