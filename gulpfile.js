const gulp = require("gulp");
const ts = require("gulp-typescript");
const { spawn } = require("child_process");
const browserSync = require("browser-sync").create();
const path = require("path");

const tsProject = ts.createProject("tsconfig.json");

// Paths
const paths = {
  // Scripts path that excludes PixelArtFilter.ts
  scripts: ["scripts/*.ts", "!scripts/PixelArtFilter.ts"],
  shaders: ["scripts/shaders/*.frag", "scripts/shaders/*.vert"],
  pixelArtFilter: ["scripts/PixelArtFilter.ts"],
  generatedFiles: ["scripts/**/*.js", "scripts/**/*.js.map"], // Files generated by TypeScript compiler
  injectScript: "tools/inject-shaders.js",
  outDir: "scripts/", // adjust if your output dir is different
};

// Run inject-shaders.js
let lastInjectTime = 0;
const DEBOUNCE_TIME = 2000; // 2 second debounce
let injectionInProgress = false;
let nextInjectionQueued = false;

function injectShaders(done) {
  const now = Date.now();

  // If already running, skip this execution
  if (injectionInProgress) {
    console.log("Skipping shader injection (already in progress)");
    nextInjectionQueued = true;
    done();
    return;
  }

  // Skip if called too soon after the last execution
  if (now - lastInjectTime < DEBOUNCE_TIME) {
    console.log("Skipping shader injection (debounced)");
    done();
    return;
  }

  injectionInProgress = true;
  lastInjectTime = now;
  console.log("Starting shader injection...");

  const proc = spawn("node", [paths.injectScript], { stdio: "inherit" });
  proc.on("close", (code) => {
    injectionInProgress = false;
    if (code !== 0) {
      done(new Error("inject-shaders failed"));
      return;
    }

    // If another injection was queued, run it now
    if (nextInjectionQueued) {
      nextInjectionQueued = false;
      // Use setTimeout to break the call stack and avoid recursion
      setTimeout(() => {
        injectShaders(done);
      }, 100);
      return;
    }

    done();
  });
}

// Compile TypeScript
function compileTS() {
  return tsProject
    .src()
    .pipe(tsProject())
    .js.pipe(
      gulp.dest((file) => {
        // Output to the same directory as the source file
        return path.dirname(file.path);
      })
    );
}

// BrowserSync for live reload
function serve(done) {
  browserSync.init({
    proxy: { target: "http://localhost:30001", ws: true }, // Change to your Foundry server port
    open: "local",
    notify: false,
    reloadDelay: 500,
  });
  done();
}

// Reload browser
function reload(done) {
  browserSync.reload();
  done();
}

// Watch files
function watchFiles() {
  // Use the raw chokidar instance for more control
  const shaderWatcher = gulp.watch(paths.shaders, {
    ignoreInitial: true,
    events: ["change"],
    queue: false, // Don't queue events
    delay: 1000, // 1 second delay to reduce duplicate events
  });
  shaderWatcher.on("change", (filePath) => {
    console.log(`Shader file changed: ${filePath}`);
    lastInjectTime = Date.now(); // Mark this as a shader-triggered injection
    gulp.series(
      injectShaders,
      compileTS,
      reload
    )((err) => {
      if (err) console.error("Error processing shader change:", err);
    });
  });

  // Watch PixelArtFilter.ts separately
  const pixelArtFilterWatcher = gulp.watch(paths.pixelArtFilter, {
    ignoreInitial: true,
    events: ["change"],
    queue: false, // Don't queue events
    delay: 1000, // 1 second delay
  });

  // Keep track of when the shader injection last ran
  let lastShaderInjection = 0;

  pixelArtFilterWatcher.on("change", (filePath) => {
    const now = Date.now();
    // Skip if PixelArtFilter was just modified by the shader injection tool
    // If file change happens within 2 seconds of shader injection, it's likely
    // caused by the shader injection itself
    if (now - lastInjectTime < 3000) {
      console.log(
        `Ignoring PixelArtFilter change at ${filePath} - likely caused by shader injection`
      );
      return;
    }

    console.log(`PixelArtFilter changed (user edit): ${filePath}`);
    gulp.series(
      injectShaders,
      compileTS,
      reload
    )((err) => {
      if (err) console.error("Error processing PixelArtFilter change:", err);
    });
  });

  // Watch all other TS files, excluding PixelArtFilter.ts
  const scriptWatcher = gulp.watch(paths.scripts, {
    ignoreInitial: true,
    events: ["change"],
    ignored: [...paths.generatedFiles], // Ignore generated files
    queue: false, // Don't queue events
    delay: 500, // 0.5 second delay
  });

  scriptWatcher.on("change", (path) => {
    console.log(`Script file changed: ${path}`);
    gulp.series(
      compileTS,
      reload
    )((err) => {
      if (err) console.error("Error processing script change:", err);
    });
  });
}

exports.default = gulp.series(injectShaders, compileTS, serve, watchFiles);
